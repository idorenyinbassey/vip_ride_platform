#!/usr/bin/env python3
"""
Security Vulnerability Testing Script for VIP Ride-Hailing Platform
==================================================================

This script tests for common security vulnerabilities in the Django REST API.
Only use this on your own applications for security assessment.

Test Categories:
1. Authentication & Authorization
2. Input Validation & Injection
3. Rate Limiting & DoS Protection
4. Data Exposure & Information Disclosure
5. Session Management
6. CORS & Headers Security
7. File Upload Security
8. API Endpoint Security
"""

import urllib.request
import urllib.parse
import json
import time
import sys
import hashlib
import base64
from datetime import datetime

class SecurityTester:
    def __init__(self, base_url="http://127.0.0.1:8000"):
        self.base_url = base_url
        self.session_token = None
        self.test_results = {
            'passed': 0,
            'failed': 0,
            'warnings': 0,
            'vulnerabilities': []
        }
        
    def log_result(self, test_name, status, message, severity="INFO"):
        """Log test results"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        if status == "PASS":
            self.test_results['passed'] += 1
            print(f"‚úÖ [{timestamp}] {test_name}: {message}")
        elif status == "FAIL":
            self.test_results['failed'] += 1
            print(f"‚ùå [{timestamp}] {test_name}: {message}")
        elif status == "WARN":
            self.test_results['warnings'] += 1
            print(f"‚ö†Ô∏è  [{timestamp}] {test_name}: {message}")
            
        if status == "FAIL" and severity in ["HIGH", "CRITICAL"]:
            self.test_results['vulnerabilities'].append({
                'test': test_name,
                'message': message,
                'severity': severity,
                'timestamp': timestamp
            })
    
    def make_request(self, endpoint, method="GET", data=None, headers=None, auth_token=None):
        """Make HTTP request with error handling"""
        try:
            url = f"{self.base_url}{endpoint}"
            
            # Prepare headers
            request_headers = {
                'User-Agent': 'SecurityTester/1.0',
                'Content-Type': 'application/json'
            }
            if headers:
                request_headers.update(headers)
            if auth_token:
                request_headers['Authorization'] = f'Bearer {auth_token}'
                
            # Prepare request
            if data and method in ['POST', 'PUT', 'PATCH']:
                if isinstance(data, dict):
                    data = json.dumps(data).encode('utf-8')
                elif isinstance(data, str):
                    data = data.encode('utf-8')
            
            req = urllib.request.Request(url, data=data, headers=request_headers)
            req.get_method = lambda: method
            
            # Make request
            with urllib.request.urlopen(req, timeout=10) as response:
                return {
                    'status_code': response.getcode(),
                    'headers': dict(response.headers),
                    'body': response.read().decode('utf-8'),
                    'success': True
                }
                
        except urllib.error.HTTPError as e:
            return {
                'status_code': e.code,
                'headers': dict(e.headers) if hasattr(e, 'headers') else {},
                'body': e.read().decode('utf-8') if hasattr(e, 'read') else str(e),
                'success': False
            }
        except Exception as e:
            # Log the network error clearly for debugging
            error_msg = f"Network error during request to {endpoint}: {str(e)}"
            print(f"‚ùå {error_msg}")
            
            return {
                'status_code': 0,
                'headers': {},
                'body': error_msg,
                'success': False,
                'error': True,
                'error_type': type(e).__name__
            }
    
    def test_authentication_bypass(self):
        """Test for authentication bypass vulnerabilities"""
        print("\nüîê Testing Authentication & Authorization")
        print("=" * 50)
        
        # Test 1: Access protected endpoints without authentication
        protected_endpoints = [
            '/api/v1/accounts/profile/',
            '/api/v1/rides/request/',
            '/api/v1/payments/history/',
            '/api/v1/fleet/vehicles/',
            '/api/v1/control-center/vip-monitoring/'
        ]
        
        for endpoint in protected_endpoints:
            response = self.make_request(endpoint)
            if response['status_code'] == 200:
                self.log_result(
                    "Auth Bypass Check",
                    "FAIL",
                    f"Protected endpoint {endpoint} accessible without authentication",
                    "HIGH"
                )
            elif response['status_code'] == 401:
                self.log_result(
                    "Auth Bypass Check",
                    "PASS",
                    f"Protected endpoint {endpoint} properly secured"
                )
            else:
                self.log_result(
                    "Auth Bypass Check",
                    "WARN",
                    f"Unexpected response {response['status_code']} for {endpoint}"
                )
        
        # Test 2: Invalid token handling
        invalid_tokens = [
            "invalid_token",
            "Bearer invalid",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.signature",
            "../../../etc/passwd",
            "<script>alert('xss')</script>"
        ]
        
        for token in invalid_tokens:
            response = self.make_request(
                '/api/v1/accounts/profile/',
                headers={'Authorization': f'Bearer {token}'}
            )
            if response['status_code'] == 200:
                self.log_result(
                    "Invalid Token Check",
                    "FAIL",
                    f"System accepts invalid token: {token[:20]}...",
                    "HIGH"
                )
            elif response['status_code'] == 401:
                self.log_result(
                    "Invalid Token Check",
                    "PASS",
                    "Invalid tokens properly rejected"
                )
    
    def test_injection_attacks(self):
        """Test for SQL injection and other injection vulnerabilities"""
        print("\nüíâ Testing Injection Vulnerabilities")
        print("=" * 50)
        
        # SQL Injection payloads
        sql_payloads = [
            "' OR '1'='1",
            "1'; DROP TABLE users; --",
            "admin'--",
            "' UNION SELECT * FROM users--",
            "1' AND 1=1--",
            "'; EXEC xp_cmdshell('dir'); --"
        ]
        
        # Test registration endpoint
        for payload in sql_payloads:
            test_data = {
                'email': f'test{payload}@example.com',
                'password': 'TestPassword123!',
                'confirm_password': 'TestPassword123!',
                'first_name': payload,
                'last_name': 'User',
                'phone_number': '+2348123456789'
            }
            
            response = self.make_request('/api/v1/accounts/register/', 'POST', test_data)
            
            # Check for specific SQL injection error patterns (not just keywords)
            sql_error_patterns = [
                'sql syntax error',
                'mysql_num_rows',
                'postgresql error',
                'sqlite3.operationalerror',
                'ora-00933',  # Oracle SQL error
                'microsoft ole db',
                'unclosed quotation mark',
                'invalid column name',
                'mysql_fetch_array',
                'pg_query() expects',
                'warning: pg_connect',
                'ora-01756'
            ]
            
            response_lower = response['body'].lower()
            sql_injection_detected = any(pattern in response_lower for pattern in sql_error_patterns)
            
            # Additional check: Look for actual SQL syntax exposure
            if "'" in payload and response['status_code'] == 500:
                # Only flag if we get a 500 error with SQL-like patterns
                if sql_injection_detected:
                    self.log_result(
                        "SQL Injection Check",
                        "FAIL",
                        f"Possible SQL injection vulnerability with payload: {payload}",
                        "CRITICAL"
                    )
                else:
                    self.log_result(
                        "SQL Injection Check",
                        "PASS",
                        f"SQL injection payload caused 500 but no SQL exposure: {payload[:20]}..."
                    )
            elif sql_injection_detected:
                self.log_result(
                    "SQL Injection Check",
                    "FAIL",
                    f"SQL error patterns detected with payload: {payload}",
                    "CRITICAL"
                )
            else:
                self.log_result(
                    "SQL Injection Check",
                    "PASS",
                    f"SQL injection payload properly handled: {payload[:20]}..."
                )
        
        # Test XSS in search endpoints
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//",
            "\"><script>alert('XSS')</script>"
        ]
        
        for payload in xss_payloads:
            # Test search functionality
            response = self.make_request(f'/api/v1/rides/search/?q={urllib.parse.quote(payload)}')
            
            if payload in response['body'] and 'text/html' in response['headers'].get('content-type', ''):
                self.log_result(
                    "XSS Check",
                    "FAIL",
                    f"Possible XSS vulnerability with payload: {payload}",
                    "HIGH"
                )
            else:
                self.log_result(
                    "XSS Check",
                    "PASS",
                    f"XSS payload properly sanitized: {payload[:20]}..."
                )
    
    def test_rate_limiting(self):
        """Test rate limiting and DoS protection"""
        print("\nüö¶ Testing Rate Limiting & DoS Protection")
        print("=" * 50)
        
        # Test registration rate limiting with randomized emails to prevent DB pollution
        import random
        import string
        
        rapid_requests = []
        created_emails = []  # Track emails for potential cleanup
        
        for i in range(20):  # Try 20 rapid requests
            # Generate random email to avoid unique constraint issues
            random_suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
            test_email = f'test_{random_suffix}_{int(time.time())}@sectest.local'
            
            test_data = {
                'email': test_email,
                'password': 'TestPassword123!',
                'confirm_password': 'TestPassword123!',
                'first_name': 'Test',
                'last_name': 'SecurityTest',
                'phone_number': f'+23481234567{i:02d}'
            }
            
            start_time = time.time()
            response = self.make_request('/api/v1/accounts/register/', 'POST', test_data)
            end_time = time.time()
            
            rapid_requests.append({
                'status': response['status_code'],
                'time': end_time - start_time
            })
            
            # Track successful registrations for potential cleanup
            if response['status_code'] == 201:
                created_emails.append(test_email)
            
            if i > 5 and response['status_code'] == 429:  # Too Many Requests
                self.log_result(
                    "Rate Limiting Check",
                    "PASS",
                    f"Rate limiting active after {i+1} requests"
                )
                break
            elif i == 19:  # All requests succeeded
                self.log_result(
                    "Rate Limiting Check",
                    "WARN",
                    "No rate limiting detected on registration endpoint"
                )
        
        # Log warning about test data (cleanup would require DB access which we don't have here)
        if created_emails:
            print(f"‚ö†Ô∏è  Created {len(created_emails)} test accounts that may need manual cleanup")
            print(f"   Test emails: {', '.join(created_emails[:3])}{'...' if len(created_emails) > 3 else ''}")
        
        # Test login brute force protection
        for i in range(10):
            login_data = {
                'email': 'admin@example.com',
                'password': f'wrongpassword{i}'
            }
            
            response = self.make_request('/api/v1/accounts/login/', 'POST', login_data)
            
            if response['status_code'] == 429:
                self.log_result(
                    "Brute Force Protection",
                    "PASS",
                    f"Account lockout/rate limiting triggered after {i+1} attempts"
                )
                break
            elif i == 9:
                self.log_result(
                    "Brute Force Protection",
                    "WARN",
                    "No brute force protection detected on login"
                )
    
    def test_information_disclosure(self):
        """Test for information disclosure vulnerabilities"""
        print("\nüîç Testing Information Disclosure")
        print("=" * 50)
        
        # Test debug information exposure
        debug_endpoints = [
            '/api/v1/debug/',
            '/api/v1/admin/',
            '/debug/',
            '/.env',
            '/config/',
            '/api/v1/health/detailed/'
        ]
        
        for endpoint in debug_endpoints:
            response = self.make_request(endpoint)
            
            # Check for sensitive information
            sensitive_patterns = [
                'SECRET_KEY', 'PASSWORD', 'DATABASE_URL', 'API_KEY',
                'Traceback', 'Debug', 'Exception', 'Error'
            ]
            
            if any(pattern in response['body'] for pattern in sensitive_patterns):
                self.log_result(
                    "Information Disclosure",
                    "FAIL",
                    f"Sensitive information exposed at {endpoint}",
                    "MEDIUM"
                )
            elif response['status_code'] == 200:
                self.log_result(
                    "Information Disclosure",
                    "WARN",
                    f"Debug endpoint accessible: {endpoint}"
                )
        
        # Test error message information disclosure
        error_endpoints = [
            '/api/v1/nonexistent/',
            '/api/v1/accounts/profile/999999/',
            '/api/v1/rides/invalid-id/'
        ]
        
        for endpoint in error_endpoints:
            response = self.make_request(endpoint)
            
            if 'Traceback' in response['body'] or 'Exception' in response['body']:
                self.log_result(
                    "Error Information Disclosure",
                    "FAIL",
                    f"Stack trace exposed in error response for {endpoint}",
                    "MEDIUM"
                )
            else:
                self.log_result(
                    "Error Information Disclosure",
                    "PASS",
                    f"Error response properly sanitized for {endpoint}"
                )
    
    def test_cors_and_headers(self):
        """Test CORS configuration and security headers"""
        print("\nüåê Testing CORS & Security Headers")
        print("=" * 50)
        
        # Test CORS configuration
        cors_response = self.make_request(
            '/api/v1/accounts/register/',
            'OPTIONS',
            headers={'Origin': 'https://malicious-site.com'}
        )
        
        cors_header = cors_response['headers'].get('access-control-allow-origin', '')
        if cors_header == '*':
            self.log_result(
                "CORS Configuration",
                "WARN",
                "CORS allows all origins (*) - potential security risk"
            )
        elif 'malicious-site.com' in cors_header:
            self.log_result(
                "CORS Configuration",
                "FAIL",
                "CORS allows malicious origins",
                "MEDIUM"
            )
        else:
            self.log_result(
                "CORS Configuration",
                "PASS",
                "CORS properly configured"
            )
        
        # Test security headers
        response = self.make_request('/api/v1/accounts/register/')
        headers = response['headers']
        
        security_headers = {
            'x-frame-options': 'DENY',
            'x-content-type-options': 'nosniff',
            'x-xss-protection': '1; mode=block',
            'strict-transport-security': 'max-age=',
            'content-security-policy': 'default-src'
        }
        
        for header, expected in security_headers.items():
            if header in headers:
                if expected in headers[header]:
                    self.log_result(
                        f"Security Header: {header}",
                        "PASS",
                        f"Header properly configured: {headers[header]}"
                    )
                else:
                    self.log_result(
                        f"Security Header: {header}",
                        "WARN",
                        f"Header present but may need review: {headers[header]}"
                    )
            else:
                self.log_result(
                    f"Security Header: {header}",
                    "WARN",
                    f"Security header missing: {header}"
                )
    
    def test_api_endpoint_security(self):
        """Test API-specific security issues"""
        print("\nüîå Testing API Endpoint Security")
        print("=" * 50)
        
        # Test HTTP methods on endpoints
        test_endpoints = [
            '/api/v1/accounts/register/',
            '/api/v1/accounts/login/',
            '/api/v1/rides/',
            '/api/v1/payments/'
        ]
        
        dangerous_methods = ['DELETE', 'PUT', 'PATCH']
        
        for endpoint in test_endpoints:
            for method in dangerous_methods:
                response = self.make_request(endpoint, method, {})
                
                if response['status_code'] == 200:
                    self.log_result(
                        f"HTTP Method Security",
                        "FAIL",
                        f"{method} method allowed on {endpoint} without authentication",
                        "MEDIUM"
                    )
                elif response['status_code'] in [401, 403]:
                    self.log_result(
                        f"HTTP Method Security",
                        "PASS",
                        f"{method} method properly secured on {endpoint}"
                    )
                elif response['status_code'] == 405:
                    self.log_result(
                        f"HTTP Method Security",
                        "PASS",
                        f"{method} method not allowed on {endpoint}"
                    )
        
        # Test parameter pollution
        pollution_data = {
            'email': ['test1@example.com', 'test2@example.com'],
            'password': ['password1', 'password2']
        }
        
        # Test with array parameters
        response = self.make_request('/api/v1/accounts/register/', 'POST', pollution_data)
        if response['status_code'] == 500:
            self.log_result(
                "Parameter Pollution",
                "WARN",
                "Server error with array parameters - potential parameter pollution vulnerability"
            )
        else:
            self.log_result(
                "Parameter Pollution",
                "PASS",
                "Array parameters handled properly"
            )
    
    def test_vip_specific_security(self):
        """Test VIP platform specific security concerns"""
        print("\nüëë Testing VIP Platform Specific Security")
        print("=" * 50)
        
        # Test GPS encryption endpoint access
        gps_response = self.make_request('/api/v1/gps/track/')
        if gps_response['status_code'] == 200:
            self.log_result(
                "GPS Encryption Access",
                "FAIL",
                "GPS tracking endpoint accessible without authentication",
                "CRITICAL"
            )
        elif gps_response['status_code'] == 401:
            self.log_result(
                "GPS Encryption Access",
                "PASS",
                "GPS tracking properly secured"
            )
        
        # Test control center access
        control_response = self.make_request('/api/v1/control-center/emergency/')
        if control_response['status_code'] == 200:
            self.log_result(
                "Control Center Access",
                "FAIL",
                "Emergency control center accessible without authentication",
                "CRITICAL"
            )
        elif control_response['status_code'] == 401:
            self.log_result(
                "Control Center Access",
                "PASS",
                "Control center properly secured"
            )
        
        # Test payment endpoint security
        payment_response = self.make_request('/api/v1/payments/process/')
        if payment_response['status_code'] == 200:
            self.log_result(
                "Payment Security",
                "FAIL",
                "Payment processing accessible without authentication",
                "CRITICAL"
            )
        elif payment_response['status_code'] == 401:
            self.log_result(
                "Payment Security",
                "PASS",
                "Payment processing properly secured"
            )
    
    def generate_report(self):
        """Generate final security report"""
        print("\n" + "=" * 60)
        print("üõ°Ô∏è  SECURITY VULNERABILITY ASSESSMENT REPORT")
        print("=" * 60)
        print(f"Test Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Target: {self.base_url}")
        print("\nüìä TEST SUMMARY:")
        print(f"‚úÖ Tests Passed: {self.test_results['passed']}")
        print(f"‚ùå Tests Failed: {self.test_results['failed']}")
        print(f"‚ö†Ô∏è  Warnings: {self.test_results['warnings']}")
        print(f"üö® Vulnerabilities Found: {len(self.test_results['vulnerabilities'])}")
        
        if self.test_results['vulnerabilities']:
            print("\nüö® CRITICAL VULNERABILITIES:")
            print("-" * 40)
            for vuln in self.test_results['vulnerabilities']:
                print(f"‚Ä¢ [{vuln['severity']}] {vuln['test']}")
                print(f"  Details: {vuln['message']}")
                print(f"  Time: {vuln['timestamp']}")
                print()
        
        # Security score calculation
        total_tests = self.test_results['passed'] + self.test_results['failed']
        if total_tests > 0:
            security_score = (self.test_results['passed'] / total_tests) * 100
            print(f"\nüèÜ SECURITY SCORE: {security_score:.1f}/100")
            
            if security_score >= 90:
                print("üü¢ Excellent security posture")
            elif security_score >= 75:
                print("üü° Good security with minor issues")
            elif security_score >= 50:
                print("üü† Moderate security - improvements needed")
            else:
                print("üî¥ Poor security - immediate action required")
        
        print("\nüìã RECOMMENDATIONS:")
        print("‚Ä¢ Ensure all endpoints require proper authentication")
        print("‚Ä¢ Implement rate limiting on all user-facing endpoints")
        print("‚Ä¢ Add comprehensive input validation and sanitization")
        print("‚Ä¢ Configure proper security headers")
        print("‚Ä¢ Regular security audits and penetration testing")
        print("‚Ä¢ Implement proper error handling without information disclosure")
        print("‚Ä¢ Use HTTPS in production with proper certificate validation")

def main():
    """Main function to run security tests"""
    print("üõ°Ô∏è  VIP Ride-Hailing Platform Security Vulnerability Scanner")
    print("=" * 70)
    print("‚ö†Ô∏è  WARNING: Only use this tool on applications you own!")
    print("=" * 70)
    
    # Initialize tester
    tester = SecurityTester()
    
    # Run all security tests
    try:
        tester.test_authentication_bypass()
        tester.test_injection_attacks()
        tester.test_rate_limiting()
        tester.test_information_disclosure()
        tester.test_cors_and_headers()
        tester.test_api_endpoint_security()
        tester.test_vip_specific_security()
        
        # Generate final report
        tester.generate_report()
        
    except KeyboardInterrupt:
        print("\nüõë Security testing interrupted by user")
    except Exception as e:
        print(f"\n‚ùå Error during security testing: {e}")
    
    print("\nüèÅ Security vulnerability assessment completed!")

if __name__ == "__main__":
    main()
